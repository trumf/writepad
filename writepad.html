<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Drawing App with Background Images</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <link rel="manifest" href="/writepad/manifest.json" />
    <meta name="theme-color" content="#ffffff" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Writepad" />
    <link rel="apple-touch-icon" href="/writepad/icons/icon-192x192.png" />

    <style>
      body {
        margin: 0;
        overflow: hidden;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      #canvasContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #guideCanvas,
      #drawingCanvas {
        position: absolute;
        top: 0;
        left: 0;
        touch-action: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
      }

      #controls {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 10;
      }

      button,
      select {
        padding: 10px 20px;
        font-size: 16px;
        margin: 5px;
        cursor: pointer;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        background-color: #ffffff;
        border: 1px solid #cccccc;
        border-radius: 4px;
      }
    </style>
  </head>

  <body>
    <div id="controls">
      <button id="nextBtn">Next</button>
      <select id="imageSelector">
        <option value="">Select an Image</option>
      </select>
      <select id="sizeSelector">
        <option value="220">Size 4 (Very Large)</option>
        <option value="120" selected>Size 3 (Large)</option>
        <option value="80">Size 2 (Medium)</option>
        <option value="40">Size 1 (Small)</option>
      </select>
      <select id="letterCountSelector">
        <option value="1">1 Letter</option>
        <option value="2">2 Letters</option>
        <option value="3">3 Letters</option>
        <option value="4">4 Letters</option>
      </select>
      <div style="display: inline-block; margin: 5px">
        <label for="fadeRateSlider" style="margin-right: 5px"
          >Fade Speed:</label
        >
        <input
          type="range"
          id="fadeRateSlider"
          min="2"
          max="15"
          value="8"
          step="1"
          style="vertical-align: middle"
        />
        <span id="fadeRateValue">0.08</span>
      </div>
      <button id="startSessionBtn">Start Session</button>
      <button id="exportSessionBtn" disabled>Export Session</button>
    </div>
    <div id="canvasContainer">
      <canvas id="guideCanvas"></canvas>
      <canvas id="drawingCanvas"></canvas>
    </div>

    <script>
      // Cache DOM elements to avoid scoping issues
      const DOM = {
        // Main elements
        guideCanvas: document.getElementById("guideCanvas"),
        drawingCanvas: document.getElementById("drawingCanvas"),
        controls: document.getElementById("controls"),
        canvasContainer: document.getElementById("canvasContainer"),

        // Control elements
        nextBtn: document.getElementById("nextBtn"),
        imageSelector: document.getElementById("imageSelector"),
        sizeSelector: document.getElementById("sizeSelector"),
        letterCountSelector: document.getElementById("letterCountSelector"),
        fadeRateSlider: document.getElementById("fadeRateSlider"),
        fadeRateValue: document.getElementById("fadeRateValue"),
        startSessionBtn: document.getElementById("startSessionBtn"),
        exportSessionBtn: document.getElementById("exportSessionBtn"),

        // Initialize toggle button later
        toggleGuidesBtn: null,
      };

      // State management
      const AppState = {
        sessionActive: false,
        sessionDrawings: {
          timestamp: null,
          drawings: [], // Will contain round objects with timestamp and images array
        },
        currentIndex: 0,
        imageOptions: [],
      };

      // Grid Configuration for layout management
      const GridConfig = {
        CELL_WIDTH: 120, // Default, will be updated
        CELL_HEIGHT: 180, // Default, will be updated
        GROUP_COUNT: 5, // Number of cells horizontally
        ROW_COUNT: 2, // Number of cells vertically (default, update on resize)
        START_X: 50, // Left margin
        START_Y: 50, // Top margin (will be calculated)
        SPACING_X: 60, // Horizontal space between cells (will be calculated)
        SPACING_Y: 60, // Vertical space between cells (will be calculated)

        update() {
          this.CELL_WIDTH = parseInt(
            document.getElementById("sizeSelector").value
          );
          this.CELL_HEIGHT = this.CELL_WIDTH * 1.5;
          this.SPACING_X = this.CELL_WIDTH * 0.5;
          this.SPACING_Y = this.CELL_HEIGHT * 0.25; // Add some vertical spacing too

          const isPortrait = window.innerHeight > window.innerWidth;
          this.ROW_COUNT = isPortrait ? 3 : 2;

          const totalGridHeight =
            this.ROW_COUNT * this.CELL_HEIGHT +
            (this.ROW_COUNT - 1) * this.SPACING_Y;
          this.START_Y = (window.innerHeight - totalGridHeight) / 2;

          // Ensure START_X is reasonable if grid is too wide
          const totalGridWidth =
            this.GROUP_COUNT * this.CELL_WIDTH +
            (this.GROUP_COUNT - 1) * this.SPACING_X;
          if (this.START_X + totalGridWidth > window.innerWidth) {
            this.START_X = Math.max(
              10,
              (window.innerWidth - totalGridWidth) / 2
            );
          } else {
            this.START_X = 50; // Reset to default if it fits
          }
        },

        getCellOrigin(row, col) {
          // Calculate top-left corner of the cell
          const x = this.START_X + col * (this.CELL_WIDTH + this.SPACING_X);
          const y = this.START_Y + row * (this.CELL_HEIGHT + this.SPACING_Y);
          return {x, y};
        },

        getCellAt(globalX, globalY) {
          // Find which cell contains the global coordinates
          // Account for spacing! Check within cell bounds only.
          for (let r = 0; r < this.ROW_COUNT; r++) {
            for (let c = 0; c < this.GROUP_COUNT; c++) {
              const origin = this.getCellOrigin(r, c);
              if (
                globalX >= origin.x &&
                globalX < origin.x + this.CELL_WIDTH &&
                globalY >= origin.y &&
                globalY < origin.y + this.CELL_HEIGHT
              ) {
                return {row: r, col: c};
              }
            }
          }
          return null; // Click was outside any cell bounds
        },
      };

      // Add this JavaScript to update the display value:
      DOM.fadeRateSlider.addEventListener("input", (e) => {
        const value = parseInt(e.target.value) / 100;
        DOM.fadeRateValue.textContent = value.toFixed(2);
      });

      // 1. Canvas Management Module
      const CanvasManager = {
        guideCanvas: document.getElementById("guideCanvas"),
        drawingCanvas: document.getElementById("drawingCanvas"),
        guideCtx: null,
        drawingCtx: null,

        init() {
          this.guideCtx = this.guideCanvas.getContext("2d");
          this.drawingCtx = this.drawingCanvas.getContext("2d");
          this.resizeCanvases();
          window.addEventListener("resize", () => this.handleResize());
        },

        resizeCanvases() {
          this.guideCanvas.width = window.innerWidth;
          this.guideCanvas.height = window.innerHeight;
          this.drawingCanvas.width = window.innerWidth;
          this.drawingCanvas.height = window.innerHeight;
        },

        handleResize() {
          const drawingContent = this.drawingCtx.getImageData(
            0,
            0,
            this.drawingCanvas.width,
            this.drawingCanvas.height
          );
          this.resizeCanvases();
          this.drawingCtx.putImageData(drawingContent, 0, 0);

          // Update grid configuration on resize
          GridConfig.update();

          imageSelector.dispatchEvent(new Event("change")); // Redraw guides
        },

        getPos(e) {
          const rect = this.drawingCanvas.getBoundingClientRect();
          if (e.touches) {
            const touch = e.touches[0] || e.changedTouches[0];
            return {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            };
          } else {
            return {
              x: e.clientX - rect.left,
              y: e.clientY - rect.top,
            };
          }
        },
      };

      // 2. Drawing Module
      const DrawingManager = {
        drawing: false,
        lastX: 0,
        lastY: 0,

        init() {
          const canvas = CanvasManager.drawingCanvas;

          // Touch Events
          canvas.addEventListener("touchstart", (e) => {
            e.preventDefault();
            this.startDrawing(e);
          });

          canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
            this.draw(e);
          });

          canvas.addEventListener("touchend", (e) => {
            e.preventDefault();
            this.stopDrawing(e);
          });

          // Mouse Events
          canvas.addEventListener("mousedown", (e) => {
            this.startDrawing(e);
          });

          canvas.addEventListener("mousemove", (e) => {
            this.draw(e);
          });

          canvas.addEventListener("mouseup", (e) => {
            this.stopDrawing(e);
          });

          canvas.addEventListener("mouseout", (e) => {
            this.stopDrawing(e);
          });
        },

        startDrawing(e) {
          this.drawing = true;
          const pos = CanvasManager.getPos(e);
          this.lastX = pos.x;
          this.lastY = pos.y;

          // If we're recording in a session, find which cell the stroke is in
          if (AppState.sessionActive) {
            const cell = GridConfig.getCellAt(pos.x, pos.y);
            if (cell) {
              const cellOrigin = GridConfig.getCellOrigin(cell.row, cell.col);
              const relPos = {
                x: pos.x - cellOrigin.x,
                y: pos.y - cellOrigin.y,
              };
              StrokeManager.startStroke(e, cell, relPos);
            } else {
              // Touch/click was outside any cell
              StrokeManager.startStroke(e);
            }
          }
        },

        draw(e) {
          if (!this.drawing) return;
          const pos = CanvasManager.getPos(e);
          const ctx = CanvasManager.drawingCtx;

          ctx.beginPath();
          ctx.moveTo(this.lastX, this.lastY);
          ctx.lineTo(pos.x, pos.y);
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 2;
          ctx.lineCap = "round";
          ctx.stroke();

          // Update for next segment
          this.lastX = pos.x;
          this.lastY = pos.y;

          // If we're in a session, add this point to the stroke recording
          if (AppState.sessionActive) {
            StrokeManager.addPoint(e, pos);
          }
        },

        stopDrawing(e) {
          if (this.drawing && AppState.sessionActive) {
            // For mouseout events that don't have a position
            const pos =
              e.clientX !== undefined
                ? CanvasManager.getPos(e)
                : {x: this.lastX, y: this.lastY};

            StrokeManager.endStroke(e, pos);
          }
          this.drawing = false;
        },
      };

      const StrokeManager = {
        currentStroke: [],
        currentStrokeCell: null, // Track which cell the current stroke belongs to
        strokes: [],
        isRecording: false,
        startTime: null,

        startStroke(e, cell, relPos) {
          if (!this.isRecording) {
            console.log("Stroke not recorded - recording not active");
            return;
          }

          if (!this.startTime) {
            this.startTime = Date.now();
          }

          // Store the cell this stroke belongs to
          this.currentStrokeCell = cell;

          // If we have cell and relPos, use relative positioning
          if (cell && relPos) {
            this.currentStroke = [
              {
                x: relPos.x,
                y: relPos.y,
                timestamp: Date.now() - this.startTime,
                pressure: e.pressure || (e.touches ? e.touches[0].force : 1.0),
                type: "start",
              },
            ];
            console.log(
              "Started new stroke in cell",
              cell,
              "at relative pos",
              relPos
            );
          } else {
            // Fall back to global coordinates for strokes outside cells
            const pos = CanvasManager.getPos(e);
            this.currentStroke = [
              {
                x: pos.x,
                y: pos.y,
                timestamp: Date.now() - this.startTime,
                pressure: e.pressure || (e.touches ? e.touches[0].force : 1.0),
                type: "start",
              },
            ];
            console.log(
              "Started new stroke outside any cell at global pos",
              pos
            );
          }
        },

        addPoint(e, globalPos) {
          if (!this.isRecording || this.currentStroke.length === 0) return;

          // If stroke is associated with a cell, store relative position
          if (this.currentStrokeCell) {
            const cellOrigin = GridConfig.getCellOrigin(
              this.currentStrokeCell.row,
              this.currentStrokeCell.col
            );
            const relPos = {
              x: globalPos.x - cellOrigin.x,
              y: globalPos.y - cellOrigin.y,
            };

            this.currentStroke.push({
              x: relPos.x,
              y: relPos.y,
              timestamp: Date.now() - this.startTime,
              pressure: e.pressure || (e.touches ? e.touches[0].force : 1.0),
              type: "move",
            });
            console.log(
              "Added point to stroke in cell",
              this.currentStrokeCell,
              "at relative pos",
              relPos
            );
          } else {
            // Use global coords for strokes outside cells
            this.currentStroke.push({
              x: globalPos.x,
              y: globalPos.y,
              timestamp: Date.now() - this.startTime,
              pressure: e.pressure || (e.touches ? e.touches[0].force : 1.0),
              type: "move",
            });
            console.log(
              "Added point to stroke outside any cell at global pos",
              globalPos
            );
          }
        },

        endStroke(e, globalPos) {
          if (!this.isRecording || this.currentStroke.length === 0) return;

          // If stroke is associated with a cell, store relative position
          if (this.currentStrokeCell) {
            const cellOrigin = GridConfig.getCellOrigin(
              this.currentStrokeCell.row,
              this.currentStrokeCell.col
            );
            const relPos = {
              x: globalPos.x - cellOrigin.x,
              y: globalPos.y - cellOrigin.y,
            };

            this.currentStroke.push({
              x: relPos.x,
              y: relPos.y,
              timestamp: Date.now() - this.startTime,
              pressure: e.pressure || (e.touches ? e.touches[0].force : 1.0),
              type: "end",
            });

            // Store the stroke with its cell info
            this.strokes.push({
              cell: {...this.currentStrokeCell},
              points: [...this.currentStroke],
            });
            console.log(
              "Ended stroke in cell",
              this.currentStrokeCell,
              "at relative pos",
              relPos
            );
          } else {
            // Use global coords for strokes outside cells
            this.currentStroke.push({
              x: globalPos.x,
              y: globalPos.y,
              timestamp: Date.now() - this.startTime,
              pressure: e.pressure || (e.touches ? e.touches[0].force : 1.0),
              type: "end",
            });

            // Store the stroke with null cell
            this.strokes.push({
              cell: null,
              points: [...this.currentStroke],
            });
            console.log(
              "Ended stroke outside any cell at global pos",
              globalPos
            );
          }

          // Reset current stroke state
          this.currentStroke = [];
          this.currentStrokeCell = null;
          console.log("Total strokes recorded:", this.strokes.length);
        },

        startRecording() {
          this.isRecording = true;
          this.startTime = Date.now();
          this.strokes = [];
          this.currentStroke = [];
          this.currentStrokeCell = null;
          console.log("Started recording strokes");
        },

        stopRecording() {
          this.isRecording = false;
          console.log("Stopped recording strokes");
          return {
            startTime: this.startTime,
            endTime: Date.now(),
            strokes: this.strokes,
          };
        },

        getStrokeData() {
          console.log(
            "Getting stroke data, total strokes:",
            this.strokes.length
          );
          const strokeData = {
            startTime: this.startTime,
            endTime: Date.now(),
            strokes: [...this.strokes], // Make a copy of the strokes array with cell info
            metadata: {
              totalStrokes: this.strokes.length,
              totalPoints: this.strokes.reduce(
                (sum, stroke) => sum + stroke.points.length,
                0
              ),
              strokesInCells: this.strokes.filter((s) => s.cell !== null)
                .length,
            },
          };
          console.log("Stroke data:", strokeData);
          return strokeData;
        },
      };
      // 3. Analytics Module
      const Analytics = {
        calculatePixelDensity(imageData) {
          let nonTransparentPixels = 0;
          for (let i = 3; i < imageData.data.length; i += 4) {
            if (imageData.data[i] > 0) nonTransparentPixels++;
          }
          return nonTransparentPixels / (imageData.width * imageData.height);
        },

        calculateStrokeCoverage(imageData) {
          const thirds = {top: 0, middle: 0, bottom: 0};
          const thirdHeight = imageData.height / 3;

          for (let y = 0; y < imageData.height; y++) {
            for (let x = 0; x < imageData.width; x++) {
              const idx = (y * imageData.width + x) * 4 + 3;
              if (imageData.data[idx] > 0) {
                if (y < thirdHeight) thirds.top++;
                else if (y < thirdHeight * 2) thirds.middle++;
                else thirds.bottom++;
              }
            }
          }

          const total = thirds.top + thirds.middle + thirds.bottom;
          if (total === 0) return thirds;

          return {
            top: thirds.top / total,
            middle: thirds.middle / total,
            bottom: thirds.bottom / total,
          };
        },
      };

      // 4. Session Management Module
      const SessionManager = {
        startSession() {
          AppState.sessionActive = true;
          AppState.sessionDrawings = {
            timestamp: new Date().toISOString().split(".")[0] + "Z",
            drawings: [],
          };

          startSessionBtn.disabled = true;
          imageSelector.disabled = false;
          exportSessionBtn.disabled = false;

          // Clear previous drawings and start fresh stroke recording
          CanvasManager.drawingCtx.clearRect(
            0,
            0,
            CanvasManager.drawingCanvas.width,
            CanvasManager.drawingCanvas.height
          );
          StrokeManager.startRecording();

          if (AppState.imageOptions.length > 0) {
            AppState.currentIndex = 0;
            imageSelector.value = AppState.imageOptions[0];
            imageSelector.dispatchEvent(new Event("change"));
          }
        },

        saveCurrentDrawing() {
          // Get the recorded stroke data for this round
          const roundStrokeData = StrokeManager.getStrokeData();
          const roundDrawings = [];
          const now = new Date();
          const roundTimestamp = now.toISOString().split(".")[0] + "Z";

          // Get primary letter information
          const primaryLetter = imageSelector.selectedOptions[0]
            ? imageSelector.selectedOptions[0].textContent
            : "unknown";
          const primaryLetterValue = imageSelector.value || "";

          // Group strokes by cell
          const strokesByCell = new Map(); // Key: "row_col", Value: array of strokes for that cell

          // Only process strokes that have valid cell information
          roundStrokeData.strokes.forEach((stroke) => {
            if (!stroke.cell) return; // Skip strokes outside cells

            const key = `${stroke.cell.row}_${stroke.cell.col}`;
            if (!strokesByCell.has(key)) {
              strokesByCell.set(key, []);
            }
            strokesByCell.get(key).push(stroke.points);
          });

          // Process each cell with strokes
          for (const [cellKey, strokesInCell] of strokesByCell.entries()) {
            if (strokesInCell.length === 0) continue; // Skip empty cells

            const [rowStr, colStr] = cellKey.split("_");
            const row = parseInt(rowStr);
            const col = parseInt(colStr);

            // Create a mini-canvas for this cell
            const miniCanvas = document.createElement("canvas");
            miniCanvas.width = GridConfig.CELL_WIDTH;
            miniCanvas.height = GridConfig.CELL_HEIGHT;
            const miniCtx = miniCanvas.getContext("2d");

            // Set drawing properties
            miniCtx.strokeStyle = "#000";
            miniCtx.lineWidth = 2;
            miniCtx.lineCap = "round";

            // Draw each stroke on the mini canvas
            strokesInCell.forEach((points) => {
              if (points.length < 2) return; // Need at least 2 points for a line

              miniCtx.beginPath();
              miniCtx.moveTo(points[0].x, points[0].y);

              // Draw each segment of the stroke
              for (let i = 1; i < points.length; i++) {
                miniCtx.lineTo(points[i].x, points[i].y);
              }

              miniCtx.stroke();
            });

            // Check if the canvas has actual content
            const imageData = miniCtx.getImageData(
              0,
              0,
              miniCanvas.width,
              miniCanvas.height
            );
            const hasContent = Array.from(imageData.data).some(
              (value, index) => index % 4 === 3 && value > 0
            );

            if (hasContent) {
              // Calculate fade rate based on column
              const fadeRate =
                parseInt(document.getElementById("fadeRateSlider").value) / 100;
              const opacity = Math.max(0.4 - fadeRate * col, 0.0);

              // Add this drawing to the round
              roundDrawings.push({
                imageData: miniCanvas.toDataURL("image/png"),
                metadata: {
                  label: primaryLetter,
                  guideImageUrl: primaryLetterValue,
                  row: row + 1, // 1-based for users
                  col: col + 1, // 1-based for users
                  guideOpacity: opacity,
                  timestamp: roundTimestamp,
                  pixelDensity: Analytics.calculatePixelDensity(imageData),
                  strokeCoverage: Analytics.calculateStrokeCoverage(imageData),
                  cellWidth: GridConfig.CELL_WIDTH,
                  cellHeight: GridConfig.CELL_HEIGHT,
                },
              });
            }
          }

          // Only save the round if we have drawings
          if (roundDrawings.length > 0) {
            AppState.sessionDrawings.drawings.push({
              timestamp: roundTimestamp,
              images: roundDrawings,
              strokeData: roundStrokeData,
            });

            // Start fresh recording for next round
            StrokeManager.startRecording();
          }
        },
      };

      const GuideManager = {
        init() {
          imageSelector.addEventListener("change", (e) =>
            this.handleImageChange(e)
          );
          this.loadImageOptions();

          // Add orientation change handler
          window.addEventListener("resize", () => {
            // Redraw current image when orientation changes
            if (imageSelector.value) {
              this.handleImageChange({target: {value: imageSelector.value}});
            }
          });
        },

        handleImageChange(e) {
          // Update grid configuration first
          GridConfig.update();

          const letterCount = parseInt(
            document.getElementById("letterCountSelector").value
          );
          const ctx = CanvasManager.guideCtx;

          // Fully clear the canvas
          ctx.clearRect(
            0,
            0,
            CanvasManager.guideCanvas.width,
            CanvasManager.guideCanvas.height
          );

          // Get random letters
          let selectedLetters = [];
          selectedLetters.push(e.target.value);

          const availableOptions = [...AppState.imageOptions].filter(
            (opt) => opt !== e.target.value
          );
          for (let i = 1; i < letterCount; i++) {
            const randomIndex = Math.floor(
              Math.random() * availableOptions.length
            );
            selectedLetters.push(availableOptions[randomIndex]);
            availableOptions.splice(randomIndex, 1);
          }

          // Load all images
          Promise.all(
            selectedLetters.map((url) => {
              return new Promise((resolve) => {
                const img = new Image();
                img.src = url;
                img.onload = () => resolve(img);
              });
            })
          ).then((images) => {
            // Clear canvas again just in case
            ctx.clearRect(
              0,
              0,
              CanvasManager.guideCanvas.width,
              CanvasManager.guideCanvas.height
            );

            // Loop through each cell in the grid
            for (let row = 0; row < GridConfig.ROW_COUNT; row++) {
              for (let col = 0; col < GridConfig.GROUP_COUNT; col++) {
                const cellOrigin = GridConfig.getCellOrigin(row, col);

                // Calculate fade based on column
                const fadeRate =
                  parseInt(document.getElementById("fadeRateSlider").value) /
                  100;
                const opacity = Math.max(0.4 - fadeRate * col, 0.0);

                // Draw guidelines for this cell
                ctx.strokeStyle = "grey";
                ctx.lineWidth = 1;
                ctx.beginPath();

                // Draw baseline (74% from top)
                ctx.moveTo(
                  cellOrigin.x,
                  cellOrigin.y + GridConfig.CELL_HEIGHT * 0.74
                );
                ctx.lineTo(
                  cellOrigin.x + GridConfig.CELL_WIDTH,
                  cellOrigin.y + GridConfig.CELL_HEIGHT * 0.74
                );

                // Draw midline (33% from top)
                ctx.moveTo(
                  cellOrigin.x,
                  cellOrigin.y + GridConfig.CELL_HEIGHT * 0.33
                );
                ctx.lineTo(
                  cellOrigin.x + GridConfig.CELL_WIDTH,
                  cellOrigin.y + GridConfig.CELL_HEIGHT * 0.33
                );

                ctx.stroke();

                // Set opacity for letter images based on column
                ctx.globalAlpha = opacity;

                // Calculate how to fit the group of letters within the cell width
                const totalImageWidthRatio = images.reduce(
                  (sum, img) => sum + img.width / img.height,
                  0
                );
                const letterSpacing =
                  images.length > 1
                    ? (GridConfig.CELL_WIDTH * 0.1) / (images.length - 1)
                    : 0;
                const availableWidth =
                  GridConfig.CELL_WIDTH - letterSpacing * (images.length - 1);

                // Draw each letter in this cell
                let currentX = cellOrigin.x;
                for (let i = 0; i < images.length; i++) {
                  const img = images[i];
                  const imgAspect = img.width / img.height;
                  const scaleFactor =
                    availableWidth /
                    totalImageWidthRatio /
                    GridConfig.CELL_HEIGHT;
                  const imgWidth =
                    imgAspect * GridConfig.CELL_HEIGHT * scaleFactor;

                  ctx.drawImage(
                    img,
                    currentX,
                    cellOrigin.y,
                    imgWidth,
                    GridConfig.CELL_HEIGHT
                  );
                  currentX +=
                    imgWidth + (i < images.length - 1 ? letterSpacing : 0);
                }
              }
            }

            // Reset global alpha
            ctx.globalAlpha = 1.0;
          });
        },

        async loadImageOptions() {
          try {
            const response = await fetch("letters.json");
            const data = await response.json();
            const images = data.lowercase;

            for (const key in images) {
              const imageUrl = `letter_images/${encodeURIComponent(
                images[key]
              )}`;
              AppState.imageOptions.push(imageUrl);

              const option = document.createElement("option");
              option.value = imageUrl;
              option.textContent = key;
              imageSelector.appendChild(option);
            }

            if (AppState.imageOptions.length > 0) {
              imageSelector.value = AppState.imageOptions[0];
              imageSelector.dispatchEvent(new Event("change"));
            }
          } catch (error) {
            console.error("Error loading dataset:", error);
          }
        },
      };

      // 6. Export Module
      const ExportManager = {
        validateSession(roundsMap, letterCount) {
          const validation = {
            status: "valid",
            issues: [],
            stats: {
              totalRounds: roundsMap.size,
              totalImages: 0,
              imagesPerRound: [],
              cellCoverage: [], // Track which cells had content
            },
          };

          for (const [timestamp, round] of roundsMap) {
            if (!round.images || round.images.length === 0) {
              validation.status = "warning";
              validation.issues.push(`Round ${timestamp} has no images`);
              validation.stats.imagesPerRound.push(0);
              continue;
            }

            // Count unique cells (row,col combinations)
            const uniqueCells = new Set();
            round.images.forEach((drawing) => {
              uniqueCells.add(
                `${drawing.metadata.row}_${drawing.metadata.col}`
              );
            });

            validation.stats.imagesPerRound.push(round.images.length);
            validation.stats.totalImages += round.images.length;
            validation.stats.cellCoverage.push(uniqueCells.size);

            // Check if we have a reasonable number of images based on grid size
            const maxPossibleCells =
              GridConfig.ROW_COUNT * GridConfig.GROUP_COUNT;
            if (uniqueCells.size > maxPossibleCells) {
              validation.status = "error";
              validation.issues.push(
                `Round ${timestamp} has more unique cells (${uniqueCells.size}) than the grid allows (${maxPossibleCells})`
              );
            }

            // Check for consistent metadata across all images
            const metadata = round.images.map((d) => d.metadata);
            const allHaveCellDimensions = metadata.every(
              (m) => m.cellWidth !== undefined && m.cellHeight !== undefined
            );

            if (!allHaveCellDimensions) {
              validation.status = "warning";
              validation.issues.push(
                `Round ${timestamp} has images missing cell dimension metadata`
              );
            }
          }

          return validation;
        },

        async exportSession() {
          if (
            !AppState.sessionActive ||
            AppState.sessionDrawings.drawings.length === 0
          )
            return;

          SessionManager.saveCurrentDrawing();

          StrokeManager.stopRecording(); // Stop recording before export

          const trainingData = {
            sessionInfo: {
              timestamp: AppState.sessionDrawings.timestamp,
              canvasWidth: CanvasManager.drawingCanvas.width,
              canvasHeight: CanvasManager.drawingCanvas.height,
              gridConfig: {
                cellWidth: GridConfig.CELL_WIDTH,
                cellHeight: GridConfig.CELL_HEIGHT,
                rowCount: GridConfig.ROW_COUNT,
                columnCount: GridConfig.GROUP_COUNT,
                spacingX: GridConfig.SPACING_X,
                spacingY: GridConfig.SPACING_Y,
                startX: GridConfig.START_X,
                startY: GridConfig.START_Y,
              },
              baselineY: GridConfig.CELL_HEIGHT * 0.74, // Baseline guide position within a cell
              midlineY: GridConfig.CELL_HEIGHT * 0.33, // Midline guide position within a cell
            },
            rounds: [],
          };

          const zip = new JSZip();
          const imagesFolder = zip.folder("images");

          // Group drawings by timestamp
          const roundsMap = new Map();
          AppState.sessionDrawings.drawings.forEach((round) => {
            roundsMap.set(round.timestamp, round);
          });

          // Add validation information
          trainingData.sessionInfo.validation = this.validateSession(
            roundsMap,
            parseInt(letterCountSelector.value)
          );

          let roundIndex = 1;
          for (const [timestamp, round] of roundsMap) {
            const roundData = {
              round: roundIndex,
              timestamp: timestamp,
              images: [],
              strokeData: round.strokeData || {}, // Include stroke data in each round
            };

            for (const drawing of round.images) {
              // Update filename to use row and col instead of position and letterIndex
              const filename = `round${roundIndex}_${drawing.metadata.label}_r${drawing.metadata.row}_c${drawing.metadata.col}.png`;

              roundData.images.push({
                filename: `images/${filename}`,
                metadata: drawing.metadata,
              });

              const base64Data = drawing.imageData.replace(
                /^data:image\/png;base64,/,
                ""
              );
              imagesFolder.file(filename, base64Data, {base64: true});
            }

            trainingData.rounds.push(roundData);
            roundIndex++;
          }

          try {
            zip.file("metadata.json", JSON.stringify(trainingData, null, 2));

            const zipBlob = await zip.generateAsync({type: "blob"});
            const zipUrl = URL.createObjectURL(zipBlob);
            const link = document.createElement("a");
            link.href = zipUrl;
            link.download = `training_data_${AppState.sessionDrawings.timestamp}.zip`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(zipUrl);

            // Reset session
            AppState.sessionActive = false;
            AppState.sessionDrawings = {
              timestamp: null,
              drawings: [],
            };
            startSessionBtn.disabled = false;
            exportSessionBtn.disabled = true;
            CanvasManager.drawingCtx.clearRect(
              0,
              0,
              CanvasManager.drawingCanvas.width,
              CanvasManager.drawingCanvas.height
            );
          } catch (err) {
            console.error("Error generating zip file:", err);
          }
        },
      };

      // Initialize the application
      function initializeApp() {
        // Get DOM elements
        const startSessionBtn = document.getElementById("startSessionBtn");
        const nextBtn = document.getElementById("nextBtn");
        const exportSessionBtn = document.getElementById("exportSessionBtn");
        const imageSelector = document.getElementById("imageSelector");
        const sizeSelector = document.getElementById("sizeSelector");

        // Initialize grid configuration
        GridConfig.update();

        // Update grid when size changes
        sizeSelector.addEventListener("change", () => {
          GridConfig.update();
          imageSelector.dispatchEvent(new Event("change")); // Redraw guides
        });

        // Add toggle button
        const toggleButton = document.createElement("button");
        toggleButton.id = "toggleGuidesBtn";
        toggleButton.textContent = "Hide Guides";
        document.getElementById("controls").appendChild(toggleButton);

        // Add visibility state to GuideManager
        GuideManager.guidesVisible = true;

        // Add toggle function to GuideManager
        GuideManager.toggleGuides = function () {
          this.guidesVisible = !this.guidesVisible;
          toggleButton.textContent = this.guidesVisible
            ? "Hide Guides"
            : "Show Guides";

          if (this.guidesVisible) {
            // Redraw guides if they're being shown
            if (imageSelector.value) {
              this.handleImageChange({target: {value: imageSelector.value}});
            }
          } else {
            // Clear the guide canvas if hiding
            const ctx = CanvasManager.guideCtx;
            ctx.clearRect(
              0,
              0,
              CanvasManager.guideCanvas.width,
              CanvasManager.guideCanvas.height
            );
          }
        };

        // Update handleImageChange to respect visibility
        const originalHandleImageChange = GuideManager.handleImageChange;
        GuideManager.handleImageChange = function (e) {
          if (!this.guidesVisible) return;
          originalHandleImageChange.call(this, e);
        };

        // Add event listener to the toggle button
        toggleButton.addEventListener("click", () =>
          GuideManager.toggleGuides()
        );

        // Initialize all modules
        CanvasManager.init();
        DrawingManager.init();
        GuideManager.init();

        // Set up event listeners
        startSessionBtn.addEventListener("click", () =>
          SessionManager.startSession()
        );
        exportSessionBtn.addEventListener("click", () =>
          ExportManager.exportSession()
        );

        nextBtn.addEventListener("click", () => {
          if (AppState.sessionActive) {
            SessionManager.saveCurrentDrawing();
            AppState.currentIndex =
              (AppState.currentIndex + 1) % AppState.imageOptions.length;
            imageSelector.value = AppState.imageOptions[AppState.currentIndex];
            imageSelector.dispatchEvent(new Event("change"));
            CanvasManager.drawingCtx.clearRect(
              0,
              0,
              CanvasManager.drawingCanvas.width,
              CanvasManager.drawingCanvas.height
            );
          } else {
            // Allow switching the guide without saving or clearing drawings
            AppState.currentIndex =
              (AppState.currentIndex + 1) % AppState.imageOptions.length;
            imageSelector.value = AppState.imageOptions[AppState.currentIndex];
            imageSelector.dispatchEvent(new Event("change"));
          }
        });
      }
      // Start the application
      initializeApp();
    </script>

    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/writepad/sw.js", {scope: "/writepad/"})
            .then((registration) => {
              console.log("ServiceWorker registration successful");
            })
            .catch((err) => {
              console.log("ServiceWorker registration failed: ", err);
            });
        });
      }
    </script>
  </body>
</html>
